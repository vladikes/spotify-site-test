"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = _interopRequireDefault(require("util"));

var _events = _interopRequireDefault(require("events"));

var _ansiEscapes = _interopRequireDefault(require("ansi-escapes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class CLInterface extends _events.default {
  constructor() {
    var _context;

    super();
    this.i = 0;
    this.stdoutBuffer = [];
    this.stderrBuffer = [];
    this.out = (_context = process.stdout).write.bind(_context);
    this.err = (_context = process.stderr).write.bind(_context);
    this.inDebugMode = false;
    this.clearAll();
    /**
     * don't modify stdout and stderr streams for unit tests
     */

    /* istanbul ignore if */

    if (!process.env.WDIO_TEST) {
      this.wrapStdio(process.stdout, this.stdoutBuffer);
      this.wrapStdio(process.stderr, this.stderrBuffer);
    }
  }

  wrapStdio(stream, buffer) {
    const out = stream.write.bind(stream);

    stream.write = chunk => {
      if (this.inDebugMode) {
        return out(chunk);
      }

      buffer.push(chunk);
      this.emit('bufferchange', chunk);
      return true;
    };
  }

  clearBuffer() {
    for (let i = this.stdoutBuffer.length; i > 0; --i) {
      this.stdoutBuffer.pop();
    }

    for (let i = this.stderrBuffer.length; i > 0; --i) {
      this.stderrBuffer.pop();
    }
  }

  clearAll() {
    this.out(_ansiEscapes.default.clearScreen);
  }

  clearLine() {
    this.out(_ansiEscapes.default.eraseStartLine);
    this.out(_ansiEscapes.default.cursorLeft);
  }

  log(...messages) {
    this.out(_util.default.format.apply(this, messages) + '\n');
  }

  write(message) {
    this.out(message);
  }

  reset() {
    process.stdout.write = this.out;
    process.stderr.write = this.err;
  }

}

exports.default = CLInterface;